#chapter 2: Vectors, Matrices, and Arrays
#input codes by copy and pasting

#5 types of basic vectors: logical, integer, real, complex, character
# cannot mix types
# character strings - entered with "" or ''
# logical values: TRUE, FALSE, T, FALSE
# missing values = NA
# the simplest way to create a vector is to use the c function

mydata = c(2.9, 3.5, 4.5, NA, 3, 2.4)
mydata
mode(mydata)
class(mydata)

single = 5
length(5)

# Numbers in R are stored in double precision real numbers
# to create an integer vector explicitly, use the L suffix
int = c(1L, 3L, 10L)
int
mode(int)
class(int)

colors = c("red", "green", "blue", "yellow", NA, "purple")
colors

newLogic = c(TRUE, NA, T, F)
newLogic

#accessing a vector
mydata = c(2.9, 3.5, 4.5, NA, 3, 2.4)
mydata
mydata[3]	#get 4.5
mydata[c(2,4,6)]	#get 3.5 NA 2.4

#a vector can also be named & accessed by names
names(mydata) = c("a", "b", "c", "d", "e", "f")
mydata
names(mydata)	#get "a" "b" "c" "d" "e" "f"
mydata["a"]		#get a 2.9
mydata[c("a", "d")]	#get a 2.9 d NA
letters[1:3]	#get "a" "b" "c"
mydata[letters[1:3]]	#get a 2.9 b 3.5 c 4.5

#to add a component to a vector, we can use the "c" function
newdata = c(mydata, 3.6)
newdata

newdata2 = c(mydata, newdata)
newdata2

#Arithmetical operations performed on vectors, element by element
a = c(1,4)
b = c(2,3)
a + b	3 get 3 7

#applying an operator = calling a function: 3 + 2 = '+' (3,2)
#2 vector of diff length, shorter one is recycled
a + 5	#get 6 9

a + c(1,2,4)	#get 2 6 5
#Warning message: In a + c(1, 2, 4): longer object length is not a multiple of shorter object length

#generating a sequence of number - using ":" operator
2:15
1:10

#alternatively -- he seq function: takes 5 arguments
# seq(from, to, by, length, along)
# seq(beginning of the sequence, end of the sequence, step size, length of the sequence, argument of the vector)
#by and length can not be used at the same time
#use along instead of to or length as length(vector) = length(result)
seq(2,10)
seq(2, 20, by=3)
seq(2,20, length=7)
x = c(3,5,8,10,0.3,4,5)
length(x)
seq(2,along = x)	#get 2 3 4 5 6 7 8
seq(2, 20, along = x)	#get 2 5 8 10 11 14 17 20

#seq has 1 unnamed argument, with length = 1 -> from = 10
seq(6)	# 1 2 3 4 5 6
#seq has 1 unnamed argument, with length > 1 -> along = x
x		#3.0 5.0 8.0 10.0 0.3 4.0 5.0
seq(x)	# 1 2 3 4 5 6 7

#the rep function: repeat an object
#2 important arguments: x(a vector) & times(# of times)
#if times is an integer -> repeat x# of times
i = rep(2,4)
i		#get 2 2 2 2
x = 1:4
rep(x, 2)	#get 1 2 3 4 1 2 3 4 
#if times is a vector & length (times) = length(x) -> repeat x[i] times [i]times
rep(x, i)	#get 1 1 2 2 3 3 4 4 
rep(x,x)	#get 1 2 2 3 3 3 4 4 4 4 

#all the random number generator functions start random
# runif(n, min=0, max=1): Uniform
# rnorm(n, mean=0, sd=1): Normal
#generate 100 number ~ Normal(2,3)
normData = rnorm(100,2,3)
mean(normData)	#get ie. 2.042951
sd(normData)	#get 2.941787

#numeric: create a double-precision vector of the specified length with each element equal to 042951
numeric(5)		#get 0 0 0 0 042951
empty = numeric(0)
empty	#get numeric(0)
length(empty)	#get 0

character(5)	#get "" "" "" "" ""
character(0)	
logical(5)		#get FALSE FALSE FALSE FALSE FALSE
logical(0)		#get logical(0)

#to create a logical vector, we can use the c function
z = c(TRUE, FALSE, T, F)
#most of the time, it is generated by condition
#relational operators: <, <=, >, >=, ==. and !=
#create a logical vector: indicating if a>3
a = c(seq(2,4), NA)
b1 = a > 20
b1		#get FALSE TRUE TRUE NA

#we can combine/negate conditions by using logical operators
#logical oeprators: &, |, !
#the recycling rules applies to these operators
b2 = a < 4
b2			#get TRUE TRUE FALSE NA
b1 & b2		#get FALSE TRUE FALSE NA
b1 | b2		#get TRUE TRUE TRUE NA
!b1			#get TRUE FALSE FALSE NA

# is.na: examine if the element of a given vector is missing
# is.na(a) != a == NA
# a == NA -> creates a vector of the same length as a with values NA
is.na(a)	#get FALSE FALSE FALSE TRUE
a == NA		#get NA NA NA NA

#in calculation: logical vector -> numeric vector TRUE -> 1, FALSE -> 0
# example: count # of elements in a vector > the mean
g <- c(seq(1,6,by = 0.5), 10)
g		#get 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0 5.5 6.0 10.0
sum(g > mean(g))	#get 5

#any: test whether at least one element of a vector is TRUE
#all: test whether all the elements of a vector is TRUE
f = c(3.01, 3.001, 3.0001, 3.00001)
any(f == 3.001)		#get TRUE
all(f > 3)			#get TRUE
all(f > 3.001)		#get FALSE

#identical: compare 2 objects, return 1 TRUE/FALSE
# == or !=: if arguments with length > 1, return a value with length > 1
identical(3, c(3, 4))		#get FALSE
3 == c(3,4)			#get TRUE FALSE

#R has a factor class to store categorical data
#when stored values as a factor class, it requires much less storage space since R only stores each unique level once
#to create a factor, you can use the factor function
countyVector = c("la", "sb", "la", "oc", "oc", "sb")
countyVector
county = factor(countyVector)	#get la sb la oc oc sb		Levels: la oc sb
#a factor is also printed without quotes

attributes(county)		#get $levels "la" "oc" "sb"		$class "factor"
#subsetting a factor
county1 = county[1:3]
county1		#get la sb la		Levels: la oc sb
nlevels(county1)	#get 3
#to eliminate the "oc" level, ...
county1  factor(county[1:3])
county1		#get la sb la 		Levels: la sb
county1[1:3, drop = T]		#get la sb la		Levels: la sb

#internaly, the factor is stored as a set of codes
print.default(county)		#get 1 3 1 2 2 3
#la stored as 1		oc stored as 2		sb stored as 3 		alphabetically
mode(county)		#get "numeric"

#some statistical functions give the 1st level a special status
#to specify the levels explicitly...
county2 = factor(countyVector, levels = c("oc", "sb", "la"))
county2		#get la sb la oc oc sb		Levels: oc sb la

#creating a factor based on numerical values
numFactor = factor(seq(1,10,by=2))
numFactor 		#get 1 3 5 7 9 		Levels: 1 3 5 7 9 
#to convert numFactor to a numeric vector, ...
as.numeric(numFactor)		#get 1 2 3 4 5
as.numeric(as.character(numFactor)		#get 1 3 5 7 9

#a vector + dim attribute -> a matrix
mydata
dim(mydata) = c(2,3)
names(mydata) 		#get NULL
#the name attrbute has been removed
#to store a matrix -> a vector
dim(mydata) = NULL
mydata		#get 2.9 3.5 4.5 NA 3.0 2.4
#the mode of a matrix is simply the mode of its element

#use the matrix function
mydata1 = matrix(mydata, 2, 3)
#to fill the matrix by row...
mydata2 = matrix(mydata, 2, 3, byrow = TRUE)
mydata2

#accessing the element of a matrix		mat[m, n] = mat[row, column]
mydata2[2,3]	#get 2.4
mydata2[2,]		#get NA 3.0 2.4
mydata2[,3]		#get 4.5 2.4

dim(mydata2)	#get 2 3
nrow(mydata2)	#get 2 or dim(mydata.2)[1]
ncol(mydata2)	#get 3 or dim(mydata.2)[2]

#a vector is an array <-> it has dim attribute/dimension vector
#the dim attribute: a vector of positive integer with length >= 10
#if the length (dim vector) = k, array is k-dimensional
# Array[m,n,k]

#you cna create an array by adding the dim attribute of a vector
x = c(1:20, rep(NA, 4))
dim(x) = c(2,3,4)

#you can also create this array by using the array function
x = array(c(1:20, rep(NA, 4)), c(2,3,4))

#each dimension can be given a set of names -> dimnames
dimnames(x) = list(d1 = c("i", "ii"), d2 = c("I", "II", "III"), d3 = + letters[1:4])
x

#NULL is used to indicate an object is absent
#NULL object should not be confused with a vector of zero length
#NULL has not type and no modifiable properties
#We cannot set attributes on NULL
mode(NULL)		#get "NULL"
class(NULL)		#get "NULL"
length(NULL)	#get 0
identical(NULL, c())	#get TRUE